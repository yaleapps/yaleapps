schema {
	query: query_root
	subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
	"""
	measured in seconds
	"""
	ttl: Int! = 60

	"""
	refresh the cache entry
	"""
	refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
	_eq: Int
	_gt: Int
	_gte: Int
	_in: [Int!]
	_is_null: Boolean
	_lt: Int
	_lte: Int
	_neq: Int
	_nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String

	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: String
	_in: [String!]

	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: String
	_is_null: Boolean

	"""
	does the column match the given pattern
	"""
	_like: String
	_lt: String
	_lte: String
	_neq: String

	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: String
	_nin: [String!]

	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: String

	"""
	does the column NOT match the given pattern
	"""
	_nlike: String

	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: String

	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: String

	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: String

	"""
	does the column match the given SQL regular expression
	"""
	_similar: String
}

"""
columns and relationships of "buildings"
"""
type buildings {
	"""
	Building full name
	"""
	building_name: String

	"""
	Building short code/abbreviation, as in YCS
	"""
	code: String!
	last_updated: timestamp

	"""
	An array relationship
	"""
	locations(
		"""
		distinct select on columns
		"""
		distinct_on: [locations_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [locations_order_by!]

		"""
		filter the rows returned
		"""
		where: locations_bool_exp
	): [locations!]!
	time_added: timestamp

	"""
	Yale campus map URL
	"""
	url: String
}

"""
Boolean expression to filter rows from the table "buildings". All fields are combined with a logical 'AND'.
"""
input buildings_bool_exp {
	_and: [buildings_bool_exp!]
	_not: buildings_bool_exp
	_or: [buildings_bool_exp!]
	building_name: String_comparison_exp
	code: String_comparison_exp
	last_updated: timestamp_comparison_exp
	locations: locations_bool_exp
	time_added: timestamp_comparison_exp
	url: String_comparison_exp
}

"""
Ordering options when selecting data from "buildings".
"""
input buildings_order_by {
	building_name: order_by
	code: order_by
	last_updated: order_by
	locations_aggregate: locations_aggregate_order_by
	time_added: order_by
	url: order_by
}

"""
select columns of table "buildings"
"""
enum buildings_select_column {
	"""
	column name
	"""
	building_name

	"""
	column name
	"""
	code

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	time_added

	"""
	column name
	"""
	url
}

"""
Streaming cursor of the table "buildings"
"""
input buildings_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: buildings_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input buildings_stream_cursor_value_input {
	"""
	Building full name
	"""
	building_name: String

	"""
	Building short code/abbreviation, as in YCS
	"""
	code: String
	last_updated: timestamp
	time_added: timestamp

	"""
	Yale campus map URL
	"""
	url: String
}

"""
columns and relationships of "course_flags"
"""
type course_flags {
	"""
	An object relationship
	"""
	course: courses!
	course_id: Int!

	"""
	An object relationship
	"""
	flag: flags!
	flag_id: Int!
}

"""
order by aggregate values of table "course_flags"
"""
input course_flags_aggregate_order_by {
	avg: course_flags_avg_order_by
	count: order_by
	max: course_flags_max_order_by
	min: course_flags_min_order_by
	stddev: course_flags_stddev_order_by
	stddev_pop: course_flags_stddev_pop_order_by
	stddev_samp: course_flags_stddev_samp_order_by
	sum: course_flags_sum_order_by
	var_pop: course_flags_var_pop_order_by
	var_samp: course_flags_var_samp_order_by
	variance: course_flags_variance_order_by
}

"""
order by avg() on columns of table "course_flags"
"""
input course_flags_avg_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
Boolean expression to filter rows from the table "course_flags". All fields are combined with a logical 'AND'.
"""
input course_flags_bool_exp {
	_and: [course_flags_bool_exp!]
	_not: course_flags_bool_exp
	_or: [course_flags_bool_exp!]
	course: courses_bool_exp
	course_id: Int_comparison_exp
	flag: flags_bool_exp
	flag_id: Int_comparison_exp
}

"""
order by max() on columns of table "course_flags"
"""
input course_flags_max_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by min() on columns of table "course_flags"
"""
input course_flags_min_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
Ordering options when selecting data from "course_flags".
"""
input course_flags_order_by {
	course: courses_order_by
	course_id: order_by
	flag: flags_order_by
	flag_id: order_by
}

"""
select columns of table "course_flags"
"""
enum course_flags_select_column {
	"""
	column name
	"""
	course_id

	"""
	column name
	"""
	flag_id
}

"""
order by stddev() on columns of table "course_flags"
"""
input course_flags_stddev_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by stddev_pop() on columns of table "course_flags"
"""
input course_flags_stddev_pop_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by stddev_samp() on columns of table "course_flags"
"""
input course_flags_stddev_samp_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
Streaming cursor of the table "course_flags"
"""
input course_flags_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: course_flags_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input course_flags_stream_cursor_value_input {
	course_id: Int
	flag_id: Int
}

"""
order by sum() on columns of table "course_flags"
"""
input course_flags_sum_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by var_pop() on columns of table "course_flags"
"""
input course_flags_var_pop_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by var_samp() on columns of table "course_flags"
"""
input course_flags_var_samp_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
order by variance() on columns of table "course_flags"
"""
input course_flags_variance_order_by {
	course_id: order_by
	flag_id: order_by
}

"""
columns and relationships of "course_meetings"
"""
type course_meetings {
	"""
	An object relationship
	"""
	course: courses!
	course_id: Int!

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: Int!

	"""
	End time of this meeting session
	"""
	end_time: String!

	"""
	An object relationship
	"""
	location: locations

	"""
	Location of this meeting session
	"""
	location_id: Int

	"""
	Start time of this meeting session
	"""
	start_time: String!
}

"""
order by aggregate values of table "course_meetings"
"""
input course_meetings_aggregate_order_by {
	avg: course_meetings_avg_order_by
	count: order_by
	max: course_meetings_max_order_by
	min: course_meetings_min_order_by
	stddev: course_meetings_stddev_order_by
	stddev_pop: course_meetings_stddev_pop_order_by
	stddev_samp: course_meetings_stddev_samp_order_by
	sum: course_meetings_sum_order_by
	var_pop: course_meetings_var_pop_order_by
	var_samp: course_meetings_var_samp_order_by
	variance: course_meetings_variance_order_by
}

"""
order by avg() on columns of table "course_meetings"
"""
input course_meetings_avg_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
Boolean expression to filter rows from the table "course_meetings". All fields are combined with a logical 'AND'.
"""
input course_meetings_bool_exp {
	_and: [course_meetings_bool_exp!]
	_not: course_meetings_bool_exp
	_or: [course_meetings_bool_exp!]
	course: courses_bool_exp
	course_id: Int_comparison_exp
	days_of_week: Int_comparison_exp
	end_time: String_comparison_exp
	location: locations_bool_exp
	location_id: Int_comparison_exp
	start_time: String_comparison_exp
}

"""
order by max() on columns of table "course_meetings"
"""
input course_meetings_max_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	End time of this meeting session
	"""
	end_time: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by

	"""
	Start time of this meeting session
	"""
	start_time: order_by
}

"""
order by min() on columns of table "course_meetings"
"""
input course_meetings_min_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	End time of this meeting session
	"""
	end_time: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by

	"""
	Start time of this meeting session
	"""
	start_time: order_by
}

"""
Ordering options when selecting data from "course_meetings".
"""
input course_meetings_order_by {
	course: courses_order_by
	course_id: order_by
	days_of_week: order_by
	end_time: order_by
	location: locations_order_by
	location_id: order_by
	start_time: order_by
}

"""
select columns of table "course_meetings"
"""
enum course_meetings_select_column {
	"""
	column name
	"""
	course_id

	"""
	column name
	"""
	days_of_week

	"""
	column name
	"""
	end_time

	"""
	column name
	"""
	location_id

	"""
	column name
	"""
	start_time
}

"""
order by stddev() on columns of table "course_meetings"
"""
input course_meetings_stddev_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
order by stddev_pop() on columns of table "course_meetings"
"""
input course_meetings_stddev_pop_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
order by stddev_samp() on columns of table "course_meetings"
"""
input course_meetings_stddev_samp_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
Streaming cursor of the table "course_meetings"
"""
input course_meetings_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: course_meetings_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input course_meetings_stream_cursor_value_input {
	course_id: Int

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: Int

	"""
	End time of this meeting session
	"""
	end_time: String

	"""
	Location of this meeting session
	"""
	location_id: Int

	"""
	Start time of this meeting session
	"""
	start_time: String
}

"""
order by sum() on columns of table "course_meetings"
"""
input course_meetings_sum_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
order by var_pop() on columns of table "course_meetings"
"""
input course_meetings_var_pop_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
order by var_samp() on columns of table "course_meetings"
"""
input course_meetings_var_samp_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
order by variance() on columns of table "course_meetings"
"""
input course_meetings_variance_order_by {
	course_id: order_by

	"""
	Days of the week for this session. It is formed through bitwise joining all the constituents, where (1 = Sunday, 2 = Monday, 4 = Tuesday, ..., 64 = Saturday). For example, if a course meets on Monday, Wednesday, and Friday, the value would be 2 + 8 + 32 = 42.
	"""
	days_of_week: order_by

	"""
	Location of this meeting session
	"""
	location_id: order_by
}

"""
columns and relationships of "course_professors"
"""
type course_professors {
	"""
	An object relationship
	"""
	course: courses!
	course_id: Int!

	"""
	An object relationship
	"""
	professor: professors!
	professor_id: Int!
}

"""
order by aggregate values of table "course_professors"
"""
input course_professors_aggregate_order_by {
	avg: course_professors_avg_order_by
	count: order_by
	max: course_professors_max_order_by
	min: course_professors_min_order_by
	stddev: course_professors_stddev_order_by
	stddev_pop: course_professors_stddev_pop_order_by
	stddev_samp: course_professors_stddev_samp_order_by
	sum: course_professors_sum_order_by
	var_pop: course_professors_var_pop_order_by
	var_samp: course_professors_var_samp_order_by
	variance: course_professors_variance_order_by
}

"""
order by avg() on columns of table "course_professors"
"""
input course_professors_avg_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
Boolean expression to filter rows from the table "course_professors". All fields are combined with a logical 'AND'.
"""
input course_professors_bool_exp {
	_and: [course_professors_bool_exp!]
	_not: course_professors_bool_exp
	_or: [course_professors_bool_exp!]
	course: courses_bool_exp
	course_id: Int_comparison_exp
	professor: professors_bool_exp
	professor_id: Int_comparison_exp
}

"""
order by max() on columns of table "course_professors"
"""
input course_professors_max_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by min() on columns of table "course_professors"
"""
input course_professors_min_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
Ordering options when selecting data from "course_professors".
"""
input course_professors_order_by {
	course: courses_order_by
	course_id: order_by
	professor: professors_order_by
	professor_id: order_by
}

"""
select columns of table "course_professors"
"""
enum course_professors_select_column {
	"""
	column name
	"""
	course_id

	"""
	column name
	"""
	professor_id
}

"""
order by stddev() on columns of table "course_professors"
"""
input course_professors_stddev_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by stddev_pop() on columns of table "course_professors"
"""
input course_professors_stddev_pop_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by stddev_samp() on columns of table "course_professors"
"""
input course_professors_stddev_samp_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
Streaming cursor of the table "course_professors"
"""
input course_professors_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: course_professors_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input course_professors_stream_cursor_value_input {
	course_id: Int
	professor_id: Int
}

"""
order by sum() on columns of table "course_professors"
"""
input course_professors_sum_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by var_pop() on columns of table "course_professors"
"""
input course_professors_var_pop_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by var_samp() on columns of table "course_professors"
"""
input course_professors_var_samp_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
order by variance() on columns of table "course_professors"
"""
input course_professors_variance_order_by {
	course_id: order_by
	professor_id: order_by
}

"""
columns and relationships of "courses"
"""
type courses {
	"""
	Course areas (humanities, social sciences, sciences)
	"""
	areas(
		"""
		JSON select path
		"""
		path: String
	): jsonb!

	"""
	Additional class notes
	"""
	classnotes: String

	"""
	True if the course is a college seminar. False otherwise.
	"""
	colsem: Boolean!

	"""
	An array relationship
	"""
	course_flags(
		"""
		distinct select on columns
		"""
		distinct_on: [course_flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_flags_order_by!]

		"""
		filter the rows returned
		"""
		where: course_flags_bool_exp
	): [course_flags!]!

	"""
	Link to the course homepage
	"""
	course_home_url: String
	course_id: Int!

	"""
	An array relationship
	"""
	course_meetings(
		"""
		distinct select on columns
		"""
		distinct_on: [course_meetings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_meetings_order_by!]

		"""
		filter the rows returned
		"""
		where: course_meetings_bool_exp
	): [course_meetings!]!

	"""
	An array relationship
	"""
	course_professors(
		"""
		distinct select on columns
		"""
		distinct_on: [course_professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_professors_order_by!]

		"""
		filter the rows returned
		"""
		where: course_professors_bool_exp
	): [course_professors!]!

	"""
	Number of course credits
	"""
	credits: float8

	"""
	Course description
	"""
	description: String

	"""
	Additional information (indicates if class has been cancelled)
	"""
	extra_info: String

	"""
	Final exam information
	"""
	final_exam: String

	"""
	True if the course is a first-year seminar. False otherwise.
	"""
	fysem: Boolean!

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: Int
	last_updated: timestamp

	"""
	An array relationship
	"""
	listings(
		"""
		distinct select on columns
		"""
		distinct_on: [listings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [listings_order_by!]

		"""
		filter the rows returned
		"""
		where: listings_bool_exp
	): [listings!]!
	primary_crn: Int

	"""
	Registrar's notes (e.g. preference selection links, optional writing credits, etc.)
	"""
	regnotes: String

	"""
	Recommended requirements/prerequisites for the course
	"""
	requirements: String

	"""
	Reading period notes
	"""
	rp_attr: String

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: Int!

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: Int!

	"""
	An object relationship
	"""
	season: seasons!

	"""
	The season the course is being taught in
	"""
	season_code: String!

	"""
	Course section. Note that the section number is the same for all cross-listings.
	"""
	section: String!

	"""
	Skills that the course fulfills (e.g. writing, quantitative reasoning, language levels)
	"""
	skills(
		"""
		JSON select path
		"""
		path: String
	): jsonb!

	"""
	Link to the syllabus
	"""
	syllabus_url: String

	"""
	True if the course is a sophomore seminar. False otherwise.
	"""
	sysem: Boolean!
	time_added: timestamp

	"""
	Complete course title
	"""
	title: String!
}

"""
order by aggregate values of table "courses"
"""
input courses_aggregate_order_by {
	avg: courses_avg_order_by
	count: order_by
	max: courses_max_order_by
	min: courses_min_order_by
	stddev: courses_stddev_order_by
	stddev_pop: courses_stddev_pop_order_by
	stddev_samp: courses_stddev_samp_order_by
	sum: courses_sum_order_by
	var_pop: courses_var_pop_order_by
	var_samp: courses_var_samp_order_by
	variance: courses_variance_order_by
}

"""
order by avg() on columns of table "courses"
"""
input courses_avg_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
Boolean expression to filter rows from the table "courses". All fields are combined with a logical 'AND'.
"""
input courses_bool_exp {
	_and: [courses_bool_exp!]
	_not: courses_bool_exp
	_or: [courses_bool_exp!]
	areas: jsonb_comparison_exp
	classnotes: String_comparison_exp
	colsem: Boolean_comparison_exp
	course_flags: course_flags_bool_exp
	course_home_url: String_comparison_exp
	course_id: Int_comparison_exp
	course_meetings: course_meetings_bool_exp
	course_professors: course_professors_bool_exp
	credits: float8_comparison_exp
	description: String_comparison_exp
	extra_info: String_comparison_exp
	final_exam: String_comparison_exp
	fysem: Boolean_comparison_exp
	last_offered_course_id: Int_comparison_exp
	last_updated: timestamp_comparison_exp
	listings: listings_bool_exp
	primary_crn: Int_comparison_exp
	regnotes: String_comparison_exp
	requirements: String_comparison_exp
	rp_attr: String_comparison_exp
	same_course_and_profs_id: Int_comparison_exp
	same_course_id: Int_comparison_exp
	season: seasons_bool_exp
	season_code: String_comparison_exp
	section: String_comparison_exp
	skills: jsonb_comparison_exp
	syllabus_url: String_comparison_exp
	sysem: Boolean_comparison_exp
	time_added: timestamp_comparison_exp
	title: String_comparison_exp
}

"""
order by max() on columns of table "courses"
"""
input courses_max_order_by {
	"""
	Additional class notes
	"""
	classnotes: order_by

	"""
	Link to the course homepage
	"""
	course_home_url: order_by
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	Course description
	"""
	description: order_by

	"""
	Additional information (indicates if class has been cancelled)
	"""
	extra_info: order_by

	"""
	Final exam information
	"""
	final_exam: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	last_updated: order_by
	primary_crn: order_by

	"""
	Registrar's notes (e.g. preference selection links, optional writing credits, etc.)
	"""
	regnotes: order_by

	"""
	Recommended requirements/prerequisites for the course
	"""
	requirements: order_by

	"""
	Reading period notes
	"""
	rp_attr: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by

	"""
	The season the course is being taught in
	"""
	season_code: order_by

	"""
	Course section. Note that the section number is the same for all cross-listings.
	"""
	section: order_by

	"""
	Link to the syllabus
	"""
	syllabus_url: order_by
	time_added: order_by

	"""
	Complete course title
	"""
	title: order_by
}

"""
order by min() on columns of table "courses"
"""
input courses_min_order_by {
	"""
	Additional class notes
	"""
	classnotes: order_by

	"""
	Link to the course homepage
	"""
	course_home_url: order_by
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	Course description
	"""
	description: order_by

	"""
	Additional information (indicates if class has been cancelled)
	"""
	extra_info: order_by

	"""
	Final exam information
	"""
	final_exam: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	last_updated: order_by
	primary_crn: order_by

	"""
	Registrar's notes (e.g. preference selection links, optional writing credits, etc.)
	"""
	regnotes: order_by

	"""
	Recommended requirements/prerequisites for the course
	"""
	requirements: order_by

	"""
	Reading period notes
	"""
	rp_attr: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by

	"""
	The season the course is being taught in
	"""
	season_code: order_by

	"""
	Course section. Note that the section number is the same for all cross-listings.
	"""
	section: order_by

	"""
	Link to the syllabus
	"""
	syllabus_url: order_by
	time_added: order_by

	"""
	Complete course title
	"""
	title: order_by
}

"""
Ordering options when selecting data from "courses".
"""
input courses_order_by {
	areas: order_by
	classnotes: order_by
	colsem: order_by
	course_flags_aggregate: course_flags_aggregate_order_by
	course_home_url: order_by
	course_id: order_by
	course_meetings_aggregate: course_meetings_aggregate_order_by
	course_professors_aggregate: course_professors_aggregate_order_by
	credits: order_by
	description: order_by
	extra_info: order_by
	final_exam: order_by
	fysem: order_by
	last_offered_course_id: order_by
	last_updated: order_by
	listings_aggregate: listings_aggregate_order_by
	primary_crn: order_by
	regnotes: order_by
	requirements: order_by
	rp_attr: order_by
	same_course_and_profs_id: order_by
	same_course_id: order_by
	season: seasons_order_by
	season_code: order_by
	section: order_by
	skills: order_by
	syllabus_url: order_by
	sysem: order_by
	time_added: order_by
	title: order_by
}

"""
select columns of table "courses"
"""
enum courses_select_column {
	"""
	column name
	"""
	areas

	"""
	column name
	"""
	classnotes

	"""
	column name
	"""
	colsem

	"""
	column name
	"""
	course_home_url

	"""
	column name
	"""
	course_id

	"""
	column name
	"""
	credits

	"""
	column name
	"""
	description

	"""
	column name
	"""
	extra_info

	"""
	column name
	"""
	final_exam

	"""
	column name
	"""
	fysem

	"""
	column name
	"""
	last_offered_course_id

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	primary_crn

	"""
	column name
	"""
	regnotes

	"""
	column name
	"""
	requirements

	"""
	column name
	"""
	rp_attr

	"""
	column name
	"""
	same_course_and_profs_id

	"""
	column name
	"""
	same_course_id

	"""
	column name
	"""
	season_code

	"""
	column name
	"""
	section

	"""
	column name
	"""
	skills

	"""
	column name
	"""
	syllabus_url

	"""
	column name
	"""
	sysem

	"""
	column name
	"""
	time_added

	"""
	column name
	"""
	title
}

"""
order by stddev() on columns of table "courses"
"""
input courses_stddev_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
order by stddev_pop() on columns of table "courses"
"""
input courses_stddev_pop_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
order by stddev_samp() on columns of table "courses"
"""
input courses_stddev_samp_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
Streaming cursor of the table "courses"
"""
input courses_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: courses_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input courses_stream_cursor_value_input {
	"""
	Course areas (humanities, social sciences, sciences)
	"""
	areas: jsonb

	"""
	Additional class notes
	"""
	classnotes: String

	"""
	True if the course is a college seminar. False otherwise.
	"""
	colsem: Boolean

	"""
	Link to the course homepage
	"""
	course_home_url: String
	course_id: Int

	"""
	Number of course credits
	"""
	credits: float8

	"""
	Course description
	"""
	description: String

	"""
	Additional information (indicates if class has been cancelled)
	"""
	extra_info: String

	"""
	Final exam information
	"""
	final_exam: String

	"""
	True if the course is a first-year seminar. False otherwise.
	"""
	fysem: Boolean

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: Int
	last_updated: timestamp
	primary_crn: Int

	"""
	Registrar's notes (e.g. preference selection links, optional writing credits, etc.)
	"""
	regnotes: String

	"""
	Recommended requirements/prerequisites for the course
	"""
	requirements: String

	"""
	Reading period notes
	"""
	rp_attr: String

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: Int

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: Int

	"""
	The season the course is being taught in
	"""
	season_code: String

	"""
	Course section. Note that the section number is the same for all cross-listings.
	"""
	section: String

	"""
	Skills that the course fulfills (e.g. writing, quantitative reasoning, language levels)
	"""
	skills: jsonb

	"""
	Link to the syllabus
	"""
	syllabus_url: String

	"""
	True if the course is a sophomore seminar. False otherwise.
	"""
	sysem: Boolean
	time_added: timestamp

	"""
	Complete course title
	"""
	title: String
}

"""
order by sum() on columns of table "courses"
"""
input courses_sum_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
order by var_pop() on columns of table "courses"
"""
input courses_var_pop_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
order by var_samp() on columns of table "courses"
"""
input courses_var_samp_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
order by variance() on columns of table "courses"
"""
input courses_variance_order_by {
	course_id: order_by

	"""
	Number of course credits
	"""
	credits: order_by

	"""
	[computed] Most recent previous offering of course (excluding future ones)
	"""
	last_offered_course_id: order_by
	primary_crn: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters. Same as 'same_course_id' with the constraint that all courses in a group were taught by the same professors.
	"""
	same_course_and_profs_id: order_by

	"""
	[computed] Unique ID for grouping courses by historical offering. All courses with a given ID are identical offerings across different semesters.
	"""
	same_course_id: order_by
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC

	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
columns and relationships of "flags"
"""
type flags {
	"""
	An array relationship
	"""
	course_flags(
		"""
		distinct select on columns
		"""
		distinct_on: [course_flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_flags_order_by!]

		"""
		filter the rows returned
		"""
		where: course_flags_bool_exp
	): [course_flags!]!

	"""
	Flag ID
	"""
	flag_id: Int!

	"""
	Flag text
	"""
	flag_text: String!
	last_updated: timestamp
	time_added: timestamp
}

"""
Boolean expression to filter rows from the table "flags". All fields are combined with a logical 'AND'.
"""
input flags_bool_exp {
	_and: [flags_bool_exp!]
	_not: flags_bool_exp
	_or: [flags_bool_exp!]
	course_flags: course_flags_bool_exp
	flag_id: Int_comparison_exp
	flag_text: String_comparison_exp
	last_updated: timestamp_comparison_exp
	time_added: timestamp_comparison_exp
}

"""
Ordering options when selecting data from "flags".
"""
input flags_order_by {
	course_flags_aggregate: course_flags_aggregate_order_by
	flag_id: order_by
	flag_text: order_by
	last_updated: order_by
	time_added: order_by
}

"""
select columns of table "flags"
"""
enum flags_select_column {
	"""
	column name
	"""
	flag_id

	"""
	column name
	"""
	flag_text

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	time_added
}

"""
Streaming cursor of the table "flags"
"""
input flags_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: flags_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input flags_stream_cursor_value_input {
	"""
	Flag ID
	"""
	flag_id: Int

	"""
	Flag text
	"""
	flag_text: String
	last_updated: timestamp
	time_added: timestamp
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
	_eq: float8
	_gt: float8
	_gte: float8
	_in: [float8!]
	_is_null: Boolean
	_lt: float8
	_lte: float8
	_neq: float8
	_nin: [float8!]
}

scalar jsonb

input jsonb_cast_exp {
	String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
	_cast: jsonb_cast_exp

	"""
	is the column contained in the given json value
	"""
	_contained_in: jsonb

	"""
	does the column contain the given json value at the top level
	"""
	_contains: jsonb
	_eq: jsonb
	_gt: jsonb
	_gte: jsonb

	"""
	does the string exist as a top-level key in the column
	"""
	_has_key: String

	"""
	do all of these strings exist as top-level keys in the column
	"""
	_has_keys_all: [String!]

	"""
	do any of these strings exist as top-level keys in the column
	"""
	_has_keys_any: [String!]
	_in: [jsonb!]
	_is_null: Boolean
	_lt: jsonb
	_lte: jsonb
	_neq: jsonb
	_nin: [jsonb!]
}

"""
columns and relationships of "listings"
"""
type listings {
	"""
	An object relationship
	"""
	course: courses!

	"""
	[computed] subject + number (e.g. "AMST 312")
	"""
	course_code: String!

	"""
	Course that the listing refers to
	"""
	course_id: Int!

	"""
	The CRN associated with this listing
	"""
	crn: Int!
	last_updated: timestamp

	"""
	Listing ID
	"""
	listing_id: Int!

	"""
	Course number in the given subject (e.g. "120" or "S120")
	"""
	number: String!

	"""
	School (e.g. YC, GS, MG) that the course is listed under
	"""
	school: String!

	"""
	An object relationship
	"""
	season: seasons!

	"""
	When the course/listing is being taught, mapping to `seasons`
	"""
	season_code: String!

	"""
	Course section. Note that the section number is the same for
	        all cross-listings.
	"""
	section: String!

	"""
	Subject the course is listed under (e.g. "AMST")
	"""
	subject: String!
	time_added: timestamp
}

"""
order by aggregate values of table "listings"
"""
input listings_aggregate_order_by {
	avg: listings_avg_order_by
	count: order_by
	max: listings_max_order_by
	min: listings_min_order_by
	stddev: listings_stddev_order_by
	stddev_pop: listings_stddev_pop_order_by
	stddev_samp: listings_stddev_samp_order_by
	sum: listings_sum_order_by
	var_pop: listings_var_pop_order_by
	var_samp: listings_var_samp_order_by
	variance: listings_variance_order_by
}

"""
order by avg() on columns of table "listings"
"""
input listings_avg_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
Boolean expression to filter rows from the table "listings". All fields are combined with a logical 'AND'.
"""
input listings_bool_exp {
	_and: [listings_bool_exp!]
	_not: listings_bool_exp
	_or: [listings_bool_exp!]
	course: courses_bool_exp
	course_code: String_comparison_exp
	course_id: Int_comparison_exp
	crn: Int_comparison_exp
	last_updated: timestamp_comparison_exp
	listing_id: Int_comparison_exp
	number: String_comparison_exp
	school: String_comparison_exp
	season: seasons_bool_exp
	season_code: String_comparison_exp
	section: String_comparison_exp
	subject: String_comparison_exp
	time_added: timestamp_comparison_exp
}

"""
order by max() on columns of table "listings"
"""
input listings_max_order_by {
	"""
	[computed] subject + number (e.g. "AMST 312")
	"""
	course_code: order_by

	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by
	last_updated: order_by

	"""
	Listing ID
	"""
	listing_id: order_by

	"""
	Course number in the given subject (e.g. "120" or "S120")
	"""
	number: order_by

	"""
	School (e.g. YC, GS, MG) that the course is listed under
	"""
	school: order_by

	"""
	When the course/listing is being taught, mapping to `seasons`
	"""
	season_code: order_by

	"""
	Course section. Note that the section number is the same for
	        all cross-listings.
	"""
	section: order_by

	"""
	Subject the course is listed under (e.g. "AMST")
	"""
	subject: order_by
	time_added: order_by
}

"""
order by min() on columns of table "listings"
"""
input listings_min_order_by {
	"""
	[computed] subject + number (e.g. "AMST 312")
	"""
	course_code: order_by

	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by
	last_updated: order_by

	"""
	Listing ID
	"""
	listing_id: order_by

	"""
	Course number in the given subject (e.g. "120" or "S120")
	"""
	number: order_by

	"""
	School (e.g. YC, GS, MG) that the course is listed under
	"""
	school: order_by

	"""
	When the course/listing is being taught, mapping to `seasons`
	"""
	season_code: order_by

	"""
	Course section. Note that the section number is the same for
	        all cross-listings.
	"""
	section: order_by

	"""
	Subject the course is listed under (e.g. "AMST")
	"""
	subject: order_by
	time_added: order_by
}

"""
Ordering options when selecting data from "listings".
"""
input listings_order_by {
	course: courses_order_by
	course_code: order_by
	course_id: order_by
	crn: order_by
	last_updated: order_by
	listing_id: order_by
	number: order_by
	school: order_by
	season: seasons_order_by
	season_code: order_by
	section: order_by
	subject: order_by
	time_added: order_by
}

"""
select columns of table "listings"
"""
enum listings_select_column {
	"""
	column name
	"""
	course_code

	"""
	column name
	"""
	course_id

	"""
	column name
	"""
	crn

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	listing_id

	"""
	column name
	"""
	number

	"""
	column name
	"""
	school

	"""
	column name
	"""
	season_code

	"""
	column name
	"""
	section

	"""
	column name
	"""
	subject

	"""
	column name
	"""
	time_added
}

"""
order by stddev() on columns of table "listings"
"""
input listings_stddev_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
order by stddev_pop() on columns of table "listings"
"""
input listings_stddev_pop_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
order by stddev_samp() on columns of table "listings"
"""
input listings_stddev_samp_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
Streaming cursor of the table "listings"
"""
input listings_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: listings_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input listings_stream_cursor_value_input {
	"""
	[computed] subject + number (e.g. "AMST 312")
	"""
	course_code: String

	"""
	Course that the listing refers to
	"""
	course_id: Int

	"""
	The CRN associated with this listing
	"""
	crn: Int
	last_updated: timestamp

	"""
	Listing ID
	"""
	listing_id: Int

	"""
	Course number in the given subject (e.g. "120" or "S120")
	"""
	number: String

	"""
	School (e.g. YC, GS, MG) that the course is listed under
	"""
	school: String

	"""
	When the course/listing is being taught, mapping to `seasons`
	"""
	season_code: String

	"""
	Course section. Note that the section number is the same for
	        all cross-listings.
	"""
	section: String

	"""
	Subject the course is listed under (e.g. "AMST")
	"""
	subject: String
	time_added: timestamp
}

"""
order by sum() on columns of table "listings"
"""
input listings_sum_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
order by var_pop() on columns of table "listings"
"""
input listings_var_pop_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
order by var_samp() on columns of table "listings"
"""
input listings_var_samp_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
order by variance() on columns of table "listings"
"""
input listings_variance_order_by {
	"""
	Course that the listing refers to
	"""
	course_id: order_by

	"""
	The CRN associated with this listing
	"""
	crn: order_by

	"""
	Listing ID
	"""
	listing_id: order_by
}

"""
columns and relationships of "locations"
"""
type locations {
	"""
	An object relationship
	"""
	building: buildings!

	"""
	Building code
	"""
	building_code: String!

	"""
	An array relationship
	"""
	course_meetings(
		"""
		distinct select on columns
		"""
		distinct_on: [course_meetings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_meetings_order_by!]

		"""
		filter the rows returned
		"""
		where: course_meetings_bool_exp
	): [course_meetings!]!
	last_updated: timestamp
	location_id: Int!

	"""
	Room number
	"""
	room: String
	time_added: timestamp
}

"""
order by aggregate values of table "locations"
"""
input locations_aggregate_order_by {
	avg: locations_avg_order_by
	count: order_by
	max: locations_max_order_by
	min: locations_min_order_by
	stddev: locations_stddev_order_by
	stddev_pop: locations_stddev_pop_order_by
	stddev_samp: locations_stddev_samp_order_by
	sum: locations_sum_order_by
	var_pop: locations_var_pop_order_by
	var_samp: locations_var_samp_order_by
	variance: locations_variance_order_by
}

"""
order by avg() on columns of table "locations"
"""
input locations_avg_order_by {
	location_id: order_by
}

"""
Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'.
"""
input locations_bool_exp {
	_and: [locations_bool_exp!]
	_not: locations_bool_exp
	_or: [locations_bool_exp!]
	building: buildings_bool_exp
	building_code: String_comparison_exp
	course_meetings: course_meetings_bool_exp
	last_updated: timestamp_comparison_exp
	location_id: Int_comparison_exp
	room: String_comparison_exp
	time_added: timestamp_comparison_exp
}

"""
order by max() on columns of table "locations"
"""
input locations_max_order_by {
	"""
	Building code
	"""
	building_code: order_by
	last_updated: order_by
	location_id: order_by

	"""
	Room number
	"""
	room: order_by
	time_added: order_by
}

"""
order by min() on columns of table "locations"
"""
input locations_min_order_by {
	"""
	Building code
	"""
	building_code: order_by
	last_updated: order_by
	location_id: order_by

	"""
	Room number
	"""
	room: order_by
	time_added: order_by
}

"""
Ordering options when selecting data from "locations".
"""
input locations_order_by {
	building: buildings_order_by
	building_code: order_by
	course_meetings_aggregate: course_meetings_aggregate_order_by
	last_updated: order_by
	location_id: order_by
	room: order_by
	time_added: order_by
}

"""
select columns of table "locations"
"""
enum locations_select_column {
	"""
	column name
	"""
	building_code

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	location_id

	"""
	column name
	"""
	room

	"""
	column name
	"""
	time_added
}

"""
order by stddev() on columns of table "locations"
"""
input locations_stddev_order_by {
	location_id: order_by
}

"""
order by stddev_pop() on columns of table "locations"
"""
input locations_stddev_pop_order_by {
	location_id: order_by
}

"""
order by stddev_samp() on columns of table "locations"
"""
input locations_stddev_samp_order_by {
	location_id: order_by
}

"""
Streaming cursor of the table "locations"
"""
input locations_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: locations_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input locations_stream_cursor_value_input {
	"""
	Building code
	"""
	building_code: String
	last_updated: timestamp
	location_id: Int

	"""
	Room number
	"""
	room: String
	time_added: timestamp
}

"""
order by sum() on columns of table "locations"
"""
input locations_sum_order_by {
	location_id: order_by
}

"""
order by var_pop() on columns of table "locations"
"""
input locations_var_pop_order_by {
	location_id: order_by
}

"""
order by var_samp() on columns of table "locations"
"""
input locations_var_samp_order_by {
	location_id: order_by
}

"""
order by variance() on columns of table "locations"
"""
input locations_variance_order_by {
	location_id: order_by
}

"""
columns and relationships of "metadata"
"""
type metadata {
	id: Int!
	last_update: timestamp
}

"""
Boolean expression to filter rows from the table "metadata". All fields are combined with a logical 'AND'.
"""
input metadata_bool_exp {
	_and: [metadata_bool_exp!]
	_not: metadata_bool_exp
	_or: [metadata_bool_exp!]
	id: Int_comparison_exp
	last_update: timestamp_comparison_exp
}

"""
Ordering options when selecting data from "metadata".
"""
input metadata_order_by {
	id: order_by
	last_update: order_by
}

"""
select columns of table "metadata"
"""
enum metadata_select_column {
	"""
	column name
	"""
	id

	"""
	column name
	"""
	last_update
}

"""
Streaming cursor of the table "metadata"
"""
input metadata_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: metadata_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input metadata_stream_cursor_value_input {
	id: Int
	last_update: timestamp
}

"""
column ordering options
"""
enum order_by {
	"""
	in ascending order, nulls last
	"""
	asc

	"""
	in ascending order, nulls first
	"""
	asc_nulls_first

	"""
	in ascending order, nulls last
	"""
	asc_nulls_last

	"""
	in descending order, nulls first
	"""
	desc

	"""
	in descending order, nulls first
	"""
	desc_nulls_first

	"""
	in descending order, nulls last
	"""
	desc_nulls_last
}

"""
columns and relationships of "professors"
"""
type professors {
	"""
	An array relationship
	"""
	course_professors(
		"""
		distinct select on columns
		"""
		distinct_on: [course_professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_professors_order_by!]

		"""
		filter the rows returned
		"""
		where: course_professors_bool_exp
	): [course_professors!]!

	"""
	[computed] Number of courses taught
	"""
	courses_taught: Int!

	"""
	Email address of the professor
	"""
	email: String
	last_updated: timestamp

	"""
	Name of the professor
	"""
	name: String!

	"""
	Professor ID
	"""
	professor_id: Int!
	time_added: timestamp
}

"""
Boolean expression to filter rows from the table "professors". All fields are combined with a logical 'AND'.
"""
input professors_bool_exp {
	_and: [professors_bool_exp!]
	_not: professors_bool_exp
	_or: [professors_bool_exp!]
	course_professors: course_professors_bool_exp
	courses_taught: Int_comparison_exp
	email: String_comparison_exp
	last_updated: timestamp_comparison_exp
	name: String_comparison_exp
	professor_id: Int_comparison_exp
	time_added: timestamp_comparison_exp
}

"""
Ordering options when selecting data from "professors".
"""
input professors_order_by {
	course_professors_aggregate: course_professors_aggregate_order_by
	courses_taught: order_by
	email: order_by
	last_updated: order_by
	name: order_by
	professor_id: order_by
	time_added: order_by
}

"""
select columns of table "professors"
"""
enum professors_select_column {
	"""
	column name
	"""
	courses_taught

	"""
	column name
	"""
	email

	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	name

	"""
	column name
	"""
	professor_id

	"""
	column name
	"""
	time_added
}

"""
Streaming cursor of the table "professors"
"""
input professors_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: professors_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input professors_stream_cursor_value_input {
	"""
	[computed] Number of courses taught
	"""
	courses_taught: Int

	"""
	Email address of the professor
	"""
	email: String
	last_updated: timestamp

	"""
	Name of the professor
	"""
	name: String

	"""
	Professor ID
	"""
	professor_id: Int
	time_added: timestamp
}

type query_root {
	"""
	fetch data from the table: "buildings"
	"""
	buildings(
		"""
		distinct select on columns
		"""
		distinct_on: [buildings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [buildings_order_by!]

		"""
		filter the rows returned
		"""
		where: buildings_bool_exp
	): [buildings!]!

	"""
	fetch data from the table: "buildings" using primary key columns
	"""
	buildings_by_pk(
		"""
		Building short code/abbreviation, as in YCS
		"""
		code: String!
	): buildings

	"""
	An array relationship
	"""
	course_flags(
		"""
		distinct select on columns
		"""
		distinct_on: [course_flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_flags_order_by!]

		"""
		filter the rows returned
		"""
		where: course_flags_bool_exp
	): [course_flags!]!

	"""
	fetch data from the table: "course_flags" using primary key columns
	"""
	course_flags_by_pk(course_id: Int!, flag_id: Int!): course_flags

	"""
	An array relationship
	"""
	course_meetings(
		"""
		distinct select on columns
		"""
		distinct_on: [course_meetings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_meetings_order_by!]

		"""
		filter the rows returned
		"""
		where: course_meetings_bool_exp
	): [course_meetings!]!

	"""
	An array relationship
	"""
	course_professors(
		"""
		distinct select on columns
		"""
		distinct_on: [course_professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_professors_order_by!]

		"""
		filter the rows returned
		"""
		where: course_professors_bool_exp
	): [course_professors!]!

	"""
	fetch data from the table: "course_professors" using primary key columns
	"""
	course_professors_by_pk(
		course_id: Int!
		professor_id: Int!
	): course_professors

	"""
	An array relationship
	"""
	courses(
		"""
		distinct select on columns
		"""
		distinct_on: [courses_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [courses_order_by!]

		"""
		filter the rows returned
		"""
		where: courses_bool_exp
	): [courses!]!

	"""
	fetch data from the table: "courses" using primary key columns
	"""
	courses_by_pk(course_id: Int!): courses

	"""
	fetch data from the table: "flags"
	"""
	flags(
		"""
		distinct select on columns
		"""
		distinct_on: [flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [flags_order_by!]

		"""
		filter the rows returned
		"""
		where: flags_bool_exp
	): [flags!]!

	"""
	fetch data from the table: "flags" using primary key columns
	"""
	flags_by_pk(
		"""
		Flag ID
		"""
		flag_id: Int!
	): flags

	"""
	An array relationship
	"""
	listings(
		"""
		distinct select on columns
		"""
		distinct_on: [listings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [listings_order_by!]

		"""
		filter the rows returned
		"""
		where: listings_bool_exp
	): [listings!]!

	"""
	fetch data from the table: "listings" using primary key columns
	"""
	listings_by_pk(
		"""
		Listing ID
		"""
		listing_id: Int!
	): listings

	"""
	An array relationship
	"""
	locations(
		"""
		distinct select on columns
		"""
		distinct_on: [locations_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [locations_order_by!]

		"""
		filter the rows returned
		"""
		where: locations_bool_exp
	): [locations!]!

	"""
	fetch data from the table: "locations" using primary key columns
	"""
	locations_by_pk(location_id: Int!): locations

	"""
	fetch data from the table: "metadata"
	"""
	metadata(
		"""
		distinct select on columns
		"""
		distinct_on: [metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: metadata_bool_exp
	): [metadata!]!

	"""
	fetch data from the table: "metadata" using primary key columns
	"""
	metadata_by_pk(id: Int!): metadata

	"""
	fetch data from the table: "professors"
	"""
	professors(
		"""
		distinct select on columns
		"""
		distinct_on: [professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [professors_order_by!]

		"""
		filter the rows returned
		"""
		where: professors_bool_exp
	): [professors!]!

	"""
	fetch data from the table: "professors" using primary key columns
	"""
	professors_by_pk(
		"""
		Professor ID
		"""
		professor_id: Int!
	): professors

	"""
	fetch data from the table: "seasons"
	"""
	seasons(
		"""
		distinct select on columns
		"""
		distinct_on: [seasons_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [seasons_order_by!]

		"""
		filter the rows returned
		"""
		where: seasons_bool_exp
	): [seasons!]!

	"""
	fetch data from the table: "seasons" using primary key columns
	"""
	seasons_by_pk(
		"""
		Season code (e.g. '202001')
		"""
		season_code: String!
	): seasons
}

"""
columns and relationships of "seasons"
"""
type seasons {
	"""
	An array relationship
	"""
	courses(
		"""
		distinct select on columns
		"""
		distinct_on: [courses_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [courses_order_by!]

		"""
		filter the rows returned
		"""
		where: courses_bool_exp
	): [courses!]!
	last_updated: timestamp

	"""
	An array relationship
	"""
	listings(
		"""
		distinct select on columns
		"""
		distinct_on: [listings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [listings_order_by!]

		"""
		filter the rows returned
		"""
		where: listings_bool_exp
	): [listings!]!

	"""
	Season code (e.g. '202001')
	"""
	season_code: String!

	"""
	[computed] Season of the semester - one of spring, summer, or fall
	"""
	term: String!
	time_added: timestamp

	"""
	[computed] Year of the semester
	"""
	year: Int!
}

"""
Boolean expression to filter rows from the table "seasons". All fields are combined with a logical 'AND'.
"""
input seasons_bool_exp {
	_and: [seasons_bool_exp!]
	_not: seasons_bool_exp
	_or: [seasons_bool_exp!]
	courses: courses_bool_exp
	last_updated: timestamp_comparison_exp
	listings: listings_bool_exp
	season_code: String_comparison_exp
	term: String_comparison_exp
	time_added: timestamp_comparison_exp
	year: Int_comparison_exp
}

"""
Ordering options when selecting data from "seasons".
"""
input seasons_order_by {
	courses_aggregate: courses_aggregate_order_by
	last_updated: order_by
	listings_aggregate: listings_aggregate_order_by
	season_code: order_by
	term: order_by
	time_added: order_by
	year: order_by
}

"""
select columns of table "seasons"
"""
enum seasons_select_column {
	"""
	column name
	"""
	last_updated

	"""
	column name
	"""
	season_code

	"""
	column name
	"""
	term

	"""
	column name
	"""
	time_added

	"""
	column name
	"""
	year
}

"""
Streaming cursor of the table "seasons"
"""
input seasons_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: seasons_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input seasons_stream_cursor_value_input {
	last_updated: timestamp

	"""
	Season code (e.g. '202001')
	"""
	season_code: String

	"""
	[computed] Season of the semester - one of spring, summer, or fall
	"""
	term: String
	time_added: timestamp

	"""
	[computed] Year of the semester
	"""
	year: Int
}

type subscription_root {
	"""
	fetch data from the table: "buildings"
	"""
	buildings(
		"""
		distinct select on columns
		"""
		distinct_on: [buildings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [buildings_order_by!]

		"""
		filter the rows returned
		"""
		where: buildings_bool_exp
	): [buildings!]!

	"""
	fetch data from the table: "buildings" using primary key columns
	"""
	buildings_by_pk(
		"""
		Building short code/abbreviation, as in YCS
		"""
		code: String!
	): buildings

	"""
	fetch data from the table in a streaming manner: "buildings"
	"""
	buildings_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [buildings_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: buildings_bool_exp
	): [buildings!]!

	"""
	An array relationship
	"""
	course_flags(
		"""
		distinct select on columns
		"""
		distinct_on: [course_flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_flags_order_by!]

		"""
		filter the rows returned
		"""
		where: course_flags_bool_exp
	): [course_flags!]!

	"""
	fetch data from the table: "course_flags" using primary key columns
	"""
	course_flags_by_pk(course_id: Int!, flag_id: Int!): course_flags

	"""
	fetch data from the table in a streaming manner: "course_flags"
	"""
	course_flags_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [course_flags_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: course_flags_bool_exp
	): [course_flags!]!

	"""
	An array relationship
	"""
	course_meetings(
		"""
		distinct select on columns
		"""
		distinct_on: [course_meetings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_meetings_order_by!]

		"""
		filter the rows returned
		"""
		where: course_meetings_bool_exp
	): [course_meetings!]!

	"""
	fetch data from the table in a streaming manner: "course_meetings"
	"""
	course_meetings_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [course_meetings_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: course_meetings_bool_exp
	): [course_meetings!]!

	"""
	An array relationship
	"""
	course_professors(
		"""
		distinct select on columns
		"""
		distinct_on: [course_professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [course_professors_order_by!]

		"""
		filter the rows returned
		"""
		where: course_professors_bool_exp
	): [course_professors!]!

	"""
	fetch data from the table: "course_professors" using primary key columns
	"""
	course_professors_by_pk(
		course_id: Int!
		professor_id: Int!
	): course_professors

	"""
	fetch data from the table in a streaming manner: "course_professors"
	"""
	course_professors_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [course_professors_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: course_professors_bool_exp
	): [course_professors!]!

	"""
	An array relationship
	"""
	courses(
		"""
		distinct select on columns
		"""
		distinct_on: [courses_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [courses_order_by!]

		"""
		filter the rows returned
		"""
		where: courses_bool_exp
	): [courses!]!

	"""
	fetch data from the table: "courses" using primary key columns
	"""
	courses_by_pk(course_id: Int!): courses

	"""
	fetch data from the table in a streaming manner: "courses"
	"""
	courses_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [courses_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: courses_bool_exp
	): [courses!]!

	"""
	fetch data from the table: "flags"
	"""
	flags(
		"""
		distinct select on columns
		"""
		distinct_on: [flags_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [flags_order_by!]

		"""
		filter the rows returned
		"""
		where: flags_bool_exp
	): [flags!]!

	"""
	fetch data from the table: "flags" using primary key columns
	"""
	flags_by_pk(
		"""
		Flag ID
		"""
		flag_id: Int!
	): flags

	"""
	fetch data from the table in a streaming manner: "flags"
	"""
	flags_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [flags_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: flags_bool_exp
	): [flags!]!

	"""
	An array relationship
	"""
	listings(
		"""
		distinct select on columns
		"""
		distinct_on: [listings_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [listings_order_by!]

		"""
		filter the rows returned
		"""
		where: listings_bool_exp
	): [listings!]!

	"""
	fetch data from the table: "listings" using primary key columns
	"""
	listings_by_pk(
		"""
		Listing ID
		"""
		listing_id: Int!
	): listings

	"""
	fetch data from the table in a streaming manner: "listings"
	"""
	listings_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [listings_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: listings_bool_exp
	): [listings!]!

	"""
	An array relationship
	"""
	locations(
		"""
		distinct select on columns
		"""
		distinct_on: [locations_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [locations_order_by!]

		"""
		filter the rows returned
		"""
		where: locations_bool_exp
	): [locations!]!

	"""
	fetch data from the table: "locations" using primary key columns
	"""
	locations_by_pk(location_id: Int!): locations

	"""
	fetch data from the table in a streaming manner: "locations"
	"""
	locations_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [locations_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: locations_bool_exp
	): [locations!]!

	"""
	fetch data from the table: "metadata"
	"""
	metadata(
		"""
		distinct select on columns
		"""
		distinct_on: [metadata_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [metadata_order_by!]

		"""
		filter the rows returned
		"""
		where: metadata_bool_exp
	): [metadata!]!

	"""
	fetch data from the table: "metadata" using primary key columns
	"""
	metadata_by_pk(id: Int!): metadata

	"""
	fetch data from the table in a streaming manner: "metadata"
	"""
	metadata_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [metadata_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: metadata_bool_exp
	): [metadata!]!

	"""
	fetch data from the table: "professors"
	"""
	professors(
		"""
		distinct select on columns
		"""
		distinct_on: [professors_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [professors_order_by!]

		"""
		filter the rows returned
		"""
		where: professors_bool_exp
	): [professors!]!

	"""
	fetch data from the table: "professors" using primary key columns
	"""
	professors_by_pk(
		"""
		Professor ID
		"""
		professor_id: Int!
	): professors

	"""
	fetch data from the table in a streaming manner: "professors"
	"""
	professors_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [professors_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: professors_bool_exp
	): [professors!]!

	"""
	fetch data from the table: "seasons"
	"""
	seasons(
		"""
		distinct select on columns
		"""
		distinct_on: [seasons_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [seasons_order_by!]

		"""
		filter the rows returned
		"""
		where: seasons_bool_exp
	): [seasons!]!

	"""
	fetch data from the table: "seasons" using primary key columns
	"""
	seasons_by_pk(
		"""
		Season code (e.g. '202001')
		"""
		season_code: String!
	): seasons

	"""
	fetch data from the table in a streaming manner: "seasons"
	"""
	seasons_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [seasons_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: seasons_bool_exp
	): [seasons!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
	_eq: timestamp
	_gt: timestamp
	_gte: timestamp
	_in: [timestamp!]
	_is_null: Boolean
	_lt: timestamp
	_lte: timestamp
	_neq: timestamp
	_nin: [timestamp!]
}
